// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: svga.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Com_Opensource_Svga_MovieParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 画布宽
  var viewBoxWidth: Float = 0

  /// 画布高
  var viewBoxHeight: Float = 0

  /// 动画每秒播放帧数，合法值是 [1, 2, 3, 5, 6, 10, 12, 15, 20, 30, 60] 中的任意一个。
  var fps: Int32 = 0

  /// 动画总帧数
  var frames: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Opensource_Svga_SpriteEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 元件所对应的位图键名, 如果 imageKey 含有 .vector 后缀，该 sprite 为矢量图层 含有 .matte 后缀，该 sprite 为遮罩图层。
  var imageKey: String = String()

  /// 帧列表
  var frames: [Com_Opensource_Svga_FrameEntity] = []

  /// 被遮罩图层的 matteKey 对应的是其遮罩图层的 imageKey.
  var matteKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Opensource_Svga_AudioEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 音频文件名
  var audioKey: String = String()

  /// 音频播放起始帧
  var startFrame: Int32 = 0

  /// 音频播放结束帧
  var endFrame: Int32 = 0

  /// 音频播放起始时间（相对音频长度）
  var startTime: Int32 = 0

  /// 音频总长度
  var totalTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Opensource_Svga_Layout: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var width: Float = 0

  var height: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Opensource_Svga_Transform: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var a: Float = 0

  var b: Float = 0

  var c: Float = 0

  var d: Float = 0

  var tx: Float = 0

  var ty: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Opensource_Svga_ShapeEntity: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 矢量类型
  var type: Com_Opensource_Svga_ShapeEntity.ShapeType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var args: OneOf_Args? {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  var shape: Com_Opensource_Svga_ShapeEntity.ShapeArgs {
    get {
      if case .shape(let v)? = _storage._args {return v}
      return Com_Opensource_Svga_ShapeEntity.ShapeArgs()
    }
    set {_uniqueStorage()._args = .shape(newValue)}
  }

  var rect: Com_Opensource_Svga_ShapeEntity.RectArgs {
    get {
      if case .rect(let v)? = _storage._args {return v}
      return Com_Opensource_Svga_ShapeEntity.RectArgs()
    }
    set {_uniqueStorage()._args = .rect(newValue)}
  }

  var ellipse: Com_Opensource_Svga_ShapeEntity.EllipseArgs {
    get {
      if case .ellipse(let v)? = _storage._args {return v}
      return Com_Opensource_Svga_ShapeEntity.EllipseArgs()
    }
    set {_uniqueStorage()._args = .ellipse(newValue)}
  }

  /// 渲染参数
  var styles: Com_Opensource_Svga_ShapeEntity.ShapeStyle {
    get {return _storage._styles ?? Com_Opensource_Svga_ShapeEntity.ShapeStyle()}
    set {_uniqueStorage()._styles = newValue}
  }
  /// Returns true if `styles` has been explicitly set.
  var hasStyles: Bool {return _storage._styles != nil}
  /// Clears the value of `styles`. Subsequent reads from it will return its default value.
  mutating func clearStyles() {_uniqueStorage()._styles = nil}

  /// 矢量图层 2D 变换矩阵
  var transform: Com_Opensource_Svga_Transform {
    get {return _storage._transform ?? Com_Opensource_Svga_Transform()}
    set {_uniqueStorage()._transform = newValue}
  }
  /// Returns true if `transform` has been explicitly set.
  var hasTransform: Bool {return _storage._transform != nil}
  /// Clears the value of `transform`. Subsequent reads from it will return its default value.
  mutating func clearTransform() {_uniqueStorage()._transform = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Args: Equatable, Sendable {
    case shape(Com_Opensource_Svga_ShapeEntity.ShapeArgs)
    case rect(Com_Opensource_Svga_ShapeEntity.RectArgs)
    case ellipse(Com_Opensource_Svga_ShapeEntity.EllipseArgs)

  }

  enum ShapeType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// 路径
    case shape // = 0

    /// 矩形
    case rect // = 1

    /// 圆形
    case ellipse // = 2

    /// 与前帧一致
    case keep // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .shape
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .shape
      case 1: self = .rect
      case 2: self = .ellipse
      case 3: self = .keep
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .shape: return 0
      case .rect: return 1
      case .ellipse: return 2
      case .keep: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Com_Opensource_Svga_ShapeEntity.ShapeType] = [
      .shape,
      .rect,
      .ellipse,
      .keep,
    ]

  }

  struct ShapeArgs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// SVG 路径
    var d: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RectArgs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var x: Float = 0

    var y: Float = 0

    var width: Float = 0

    var height: Float = 0

    /// 圆角半径
    var cornerRadius: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EllipseArgs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 圆中心点 X
    var x: Float = 0

    /// 圆中心点 Y
    var y: Float = 0

    /// 横向半径
    var radiusX: Float = 0

    /// 纵向半径
    var radiusY: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ShapeStyle: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 填充色
    var fill: Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor {
      get {return _fill ?? Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor()}
      set {_fill = newValue}
    }
    /// Returns true if `fill` has been explicitly set.
    var hasFill: Bool {return self._fill != nil}
    /// Clears the value of `fill`. Subsequent reads from it will return its default value.
    mutating func clearFill() {self._fill = nil}

    /// 描边色
    var stroke: Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor {
      get {return _stroke ?? Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor()}
      set {_stroke = newValue}
    }
    /// Returns true if `stroke` has been explicitly set.
    var hasStroke: Bool {return self._stroke != nil}
    /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
    mutating func clearStroke() {self._stroke = nil}

    /// 描边宽
    var strokeWidth: Float = 0

    /// 线段端点样式
    var lineCap: Com_Opensource_Svga_ShapeEntity.ShapeStyle.LineCap = .butt

    /// 线段连接样式
    var lineJoin: Com_Opensource_Svga_ShapeEntity.ShapeStyle.LineJoin = .miter

    /// 尖角限制
    var miterLimit: Float = 0

    /// 虚线参数 Dash
    var lineDashI: Float = 0

    /// 虚线参数 Gap
    var lineDashIi: Float = 0

    /// 虚线参数 Offset
    var lineDashIii: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum LineCap: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case butt // = 0
      case round // = 1
      case square // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .butt
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .butt
        case 1: self = .round
        case 2: self = .square
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .butt: return 0
        case .round: return 1
        case .square: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Com_Opensource_Svga_ShapeEntity.ShapeStyle.LineCap] = [
        .butt,
        .round,
        .square,
      ]

    }

    enum LineJoin: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case miter // = 0
      case round // = 1
      case bevel // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .miter
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .miter
        case 1: self = .round
        case 2: self = .bevel
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .miter: return 0
        case .round: return 1
        case .bevel: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Com_Opensource_Svga_ShapeEntity.ShapeStyle.LineJoin] = [
        .miter,
        .round,
        .bevel,
      ]

    }

    struct RGBAColor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var r: Float = 0

      var g: Float = 0

      var b: Float = 0

      var a: Float = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _fill: Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor? = nil
    fileprivate var _stroke: Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Com_Opensource_Svga_FrameEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 透明度
  var alpha: Float = 0

  /// 初始约束大小
  var layout: Com_Opensource_Svga_Layout {
    get {return _layout ?? Com_Opensource_Svga_Layout()}
    set {_layout = newValue}
  }
  /// Returns true if `layout` has been explicitly set.
  var hasLayout: Bool {return self._layout != nil}
  /// Clears the value of `layout`. Subsequent reads from it will return its default value.
  mutating func clearLayout() {self._layout = nil}

  /// 2D 变换矩阵
  var transform: Com_Opensource_Svga_Transform {
    get {return _transform ?? Com_Opensource_Svga_Transform()}
    set {_transform = newValue}
  }
  /// Returns true if `transform` has been explicitly set.
  var hasTransform: Bool {return self._transform != nil}
  /// Clears the value of `transform`. Subsequent reads from it will return its default value.
  mutating func clearTransform() {self._transform = nil}

  /// 遮罩路径，使用 SVG 标准 Path 绘制图案进行 Mask 遮罩。
  var clipPath: String = String()

  /// 矢量元素列表
  var shapes: [Com_Opensource_Svga_ShapeEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _layout: Com_Opensource_Svga_Layout? = nil
  fileprivate var _transform: Com_Opensource_Svga_Transform? = nil
}

struct Com_Opensource_Svga_MovieEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SVGA 格式版本号
  var version: String = String()

  /// 动画参数
  var params: Com_Opensource_Svga_MovieParams {
    get {return _params ?? Com_Opensource_Svga_MovieParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  /// Key 是位图键名，Value 是位图文件名或二进制 PNG 数据。
  var images: Dictionary<String,Data> = [:]

  /// 元素列表
  var sprites: [Com_Opensource_Svga_SpriteEntity] = []

  /// 音频列表
  var audios: [Com_Opensource_Svga_AudioEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Com_Opensource_Svga_MovieParams? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.opensource.svga"

extension Com_Opensource_Svga_MovieParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MovieParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewBoxWidth"),
    2: .same(proto: "viewBoxHeight"),
    3: .same(proto: "fps"),
    4: .same(proto: "frames"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.viewBoxWidth) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.viewBoxHeight) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.fps) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.frames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.viewBoxWidth.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.viewBoxWidth, fieldNumber: 1)
    }
    if self.viewBoxHeight.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.viewBoxHeight, fieldNumber: 2)
    }
    if self.fps != 0 {
      try visitor.visitSingularInt32Field(value: self.fps, fieldNumber: 3)
    }
    if self.frames != 0 {
      try visitor.visitSingularInt32Field(value: self.frames, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_MovieParams, rhs: Com_Opensource_Svga_MovieParams) -> Bool {
    if lhs.viewBoxWidth != rhs.viewBoxWidth {return false}
    if lhs.viewBoxHeight != rhs.viewBoxHeight {return false}
    if lhs.fps != rhs.fps {return false}
    if lhs.frames != rhs.frames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_SpriteEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpriteEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "imageKey"),
    2: .same(proto: "frames"),
    3: .same(proto: "matteKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imageKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.frames) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.matteKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageKey.isEmpty {
      try visitor.visitSingularStringField(value: self.imageKey, fieldNumber: 1)
    }
    if !self.frames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frames, fieldNumber: 2)
    }
    if !self.matteKey.isEmpty {
      try visitor.visitSingularStringField(value: self.matteKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_SpriteEntity, rhs: Com_Opensource_Svga_SpriteEntity) -> Bool {
    if lhs.imageKey != rhs.imageKey {return false}
    if lhs.frames != rhs.frames {return false}
    if lhs.matteKey != rhs.matteKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_AudioEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audioKey"),
    2: .same(proto: "startFrame"),
    3: .same(proto: "endFrame"),
    4: .same(proto: "startTime"),
    5: .same(proto: "totalTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.audioKey) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startFrame) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endFrame) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.startTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioKey.isEmpty {
      try visitor.visitSingularStringField(value: self.audioKey, fieldNumber: 1)
    }
    if self.startFrame != 0 {
      try visitor.visitSingularInt32Field(value: self.startFrame, fieldNumber: 2)
    }
    if self.endFrame != 0 {
      try visitor.visitSingularInt32Field(value: self.endFrame, fieldNumber: 3)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt32Field(value: self.startTime, fieldNumber: 4)
    }
    if self.totalTime != 0 {
      try visitor.visitSingularInt32Field(value: self.totalTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_AudioEntity, rhs: Com_Opensource_Svga_AudioEntity) -> Bool {
    if lhs.audioKey != rhs.audioKey {return false}
    if lhs.startFrame != rhs.startFrame {return false}
    if lhs.endFrame != rhs.endFrame {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.totalTime != rhs.totalTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_Layout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Layout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.width.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 3)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_Layout, rhs: Com_Opensource_Svga_Layout) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_Transform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transform"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "a"),
    2: .same(proto: "b"),
    3: .same(proto: "c"),
    4: .same(proto: "d"),
    5: .same(proto: "tx"),
    6: .same(proto: "ty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.a) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.b) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.c) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.d) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.tx) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.ty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.a.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.a, fieldNumber: 1)
    }
    if self.b.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.b, fieldNumber: 2)
    }
    if self.c.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.c, fieldNumber: 3)
    }
    if self.d.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.d, fieldNumber: 4)
    }
    if self.tx.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tx, fieldNumber: 5)
    }
    if self.ty.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.ty, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_Transform, rhs: Com_Opensource_Svga_Transform) -> Bool {
    if lhs.a != rhs.a {return false}
    if lhs.b != rhs.b {return false}
    if lhs.c != rhs.c {return false}
    if lhs.d != rhs.d {return false}
    if lhs.tx != rhs.tx {return false}
    if lhs.ty != rhs.ty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_ShapeEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "shape"),
    3: .same(proto: "rect"),
    4: .same(proto: "ellipse"),
    10: .same(proto: "styles"),
    11: .same(proto: "transform"),
  ]

  fileprivate class _StorageClass {
    var _type: Com_Opensource_Svga_ShapeEntity.ShapeType = .shape
    var _args: Com_Opensource_Svga_ShapeEntity.OneOf_Args?
    var _styles: Com_Opensource_Svga_ShapeEntity.ShapeStyle? = nil
    var _transform: Com_Opensource_Svga_Transform? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _args = source._args
      _styles = source._styles
      _transform = source._transform
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try {
          var v: Com_Opensource_Svga_ShapeEntity.ShapeArgs?
          var hadOneofValue = false
          if let current = _storage._args {
            hadOneofValue = true
            if case .shape(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._args = .shape(v)
          }
        }()
        case 3: try {
          var v: Com_Opensource_Svga_ShapeEntity.RectArgs?
          var hadOneofValue = false
          if let current = _storage._args {
            hadOneofValue = true
            if case .rect(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._args = .rect(v)
          }
        }()
        case 4: try {
          var v: Com_Opensource_Svga_ShapeEntity.EllipseArgs?
          var hadOneofValue = false
          if let current = _storage._args {
            hadOneofValue = true
            if case .ellipse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._args = .ellipse(v)
          }
        }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._styles) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._transform) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .shape {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      switch _storage._args {
      case .shape?: try {
        guard case .shape(let v)? = _storage._args else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .rect?: try {
        guard case .rect(let v)? = _storage._args else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .ellipse?: try {
        guard case .ellipse(let v)? = _storage._args else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
      try { if let v = _storage._styles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._transform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_ShapeEntity, rhs: Com_Opensource_Svga_ShapeEntity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._styles != rhs_storage._styles {return false}
        if _storage._transform != rhs_storage._transform {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_ShapeEntity.ShapeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHAPE"),
    1: .same(proto: "RECT"),
    2: .same(proto: "ELLIPSE"),
    3: .same(proto: "KEEP"),
  ]
}

extension Com_Opensource_Svga_ShapeEntity.ShapeArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Com_Opensource_Svga_ShapeEntity.protoMessageName + ".ShapeArgs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "d"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.d) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.d.isEmpty {
      try visitor.visitSingularStringField(value: self.d, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_ShapeEntity.ShapeArgs, rhs: Com_Opensource_Svga_ShapeEntity.ShapeArgs) -> Bool {
    if lhs.d != rhs.d {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_ShapeEntity.RectArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Com_Opensource_Svga_ShapeEntity.protoMessageName + ".RectArgs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
    5: .same(proto: "cornerRadius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.cornerRadius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.width.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 3)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 4)
    }
    if self.cornerRadius.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.cornerRadius, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_ShapeEntity.RectArgs, rhs: Com_Opensource_Svga_ShapeEntity.RectArgs) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.cornerRadius != rhs.cornerRadius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_ShapeEntity.EllipseArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Com_Opensource_Svga_ShapeEntity.protoMessageName + ".EllipseArgs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "radiusX"),
    4: .same(proto: "radiusY"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.radiusX) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.radiusY) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.radiusX.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.radiusX, fieldNumber: 3)
    }
    if self.radiusY.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.radiusY, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_ShapeEntity.EllipseArgs, rhs: Com_Opensource_Svga_ShapeEntity.EllipseArgs) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.radiusX != rhs.radiusX {return false}
    if lhs.radiusY != rhs.radiusY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_ShapeEntity.ShapeStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Com_Opensource_Svga_ShapeEntity.protoMessageName + ".ShapeStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fill"),
    2: .same(proto: "stroke"),
    3: .same(proto: "strokeWidth"),
    4: .same(proto: "lineCap"),
    5: .same(proto: "lineJoin"),
    6: .same(proto: "miterLimit"),
    7: .same(proto: "lineDashI"),
    8: .same(proto: "lineDashII"),
    9: .same(proto: "lineDashIII"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stroke) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.strokeWidth) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.lineCap) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.lineJoin) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.miterLimit) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.lineDashI) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.lineDashIi) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.lineDashIii) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.strokeWidth.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.strokeWidth, fieldNumber: 3)
    }
    if self.lineCap != .butt {
      try visitor.visitSingularEnumField(value: self.lineCap, fieldNumber: 4)
    }
    if self.lineJoin != .miter {
      try visitor.visitSingularEnumField(value: self.lineJoin, fieldNumber: 5)
    }
    if self.miterLimit.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.miterLimit, fieldNumber: 6)
    }
    if self.lineDashI.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.lineDashI, fieldNumber: 7)
    }
    if self.lineDashIi.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.lineDashIi, fieldNumber: 8)
    }
    if self.lineDashIii.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.lineDashIii, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_ShapeEntity.ShapeStyle, rhs: Com_Opensource_Svga_ShapeEntity.ShapeStyle) -> Bool {
    if lhs._fill != rhs._fill {return false}
    if lhs._stroke != rhs._stroke {return false}
    if lhs.strokeWidth != rhs.strokeWidth {return false}
    if lhs.lineCap != rhs.lineCap {return false}
    if lhs.lineJoin != rhs.lineJoin {return false}
    if lhs.miterLimit != rhs.miterLimit {return false}
    if lhs.lineDashI != rhs.lineDashI {return false}
    if lhs.lineDashIi != rhs.lineDashIi {return false}
    if lhs.lineDashIii != rhs.lineDashIii {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_ShapeEntity.ShapeStyle.LineCap: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LineCap_BUTT"),
    1: .same(proto: "LineCap_ROUND"),
    2: .same(proto: "LineCap_SQUARE"),
  ]
}

extension Com_Opensource_Svga_ShapeEntity.ShapeStyle.LineJoin: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LineJoin_MITER"),
    1: .same(proto: "LineJoin_ROUND"),
    2: .same(proto: "LineJoin_BEVEL"),
  ]
}

extension Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Com_Opensource_Svga_ShapeEntity.ShapeStyle.protoMessageName + ".RGBAColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "g"),
    3: .same(proto: "b"),
    4: .same(proto: "a"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.r) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.g) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.b) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.a) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.r.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.r, fieldNumber: 1)
    }
    if self.g.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.g, fieldNumber: 2)
    }
    if self.b.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.b, fieldNumber: 3)
    }
    if self.a.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.a, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor, rhs: Com_Opensource_Svga_ShapeEntity.ShapeStyle.RGBAColor) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.g != rhs.g {return false}
    if lhs.b != rhs.b {return false}
    if lhs.a != rhs.a {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_FrameEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FrameEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "layout"),
    3: .same(proto: "transform"),
    4: .same(proto: "clipPath"),
    5: .same(proto: "shapes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._layout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clipPath) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.shapes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.alpha.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try { if let v = self._layout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._transform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.clipPath.isEmpty {
      try visitor.visitSingularStringField(value: self.clipPath, fieldNumber: 4)
    }
    if !self.shapes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shapes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_FrameEntity, rhs: Com_Opensource_Svga_FrameEntity) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs._layout != rhs._layout {return false}
    if lhs._transform != rhs._transform {return false}
    if lhs.clipPath != rhs.clipPath {return false}
    if lhs.shapes != rhs.shapes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Opensource_Svga_MovieEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MovieEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "params"),
    3: .same(proto: "images"),
    4: .same(proto: "sprites"),
    5: .same(proto: "audios"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.images) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sprites) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.audios) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.images.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.images, fieldNumber: 3)
    }
    if !self.sprites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sprites, fieldNumber: 4)
    }
    if !self.audios.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audios, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Opensource_Svga_MovieEntity, rhs: Com_Opensource_Svga_MovieEntity) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._params != rhs._params {return false}
    if lhs.images != rhs.images {return false}
    if lhs.sprites != rhs.sprites {return false}
    if lhs.audios != rhs.audios {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
